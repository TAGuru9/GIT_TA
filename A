<#
SSO Health Check (Sliced)
- DNS + TCP + HTTP
- SSO-friendly: 200/3xx/401/403 are PASS
- Captures redirect Location header
- Exports CSV/JSON
#>

[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
$ProgressPreference = "SilentlyContinue"

# ---- CONFIG ----
$Websites = @(
    @{ Name="AmeriFlex";      Url="https://www.wealthcareadmin.com/selfservicelogin.aspx" },
    @{ Name="RIVS";          Url="https://login.rivs.com" },
    @{ Name="HealthEquity";  Url="https://}
)

# SSO "healthy" HTTP codes
$PassCodes = @(200,301,302,303,307,308,401,403)

# Expected IdP keywords (optional validation)
$IdpKeywords = @("okta", "microsoftonline", "adfs", "oauth", "saml", "authorize")

# Browser-like UA reduces bot false-fails
$Headers = @{
  "User-Agent" = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0 Safari/537.36"
  "Accept"     = "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8"
}

function Test-Dns {
    param([string]$HostName)
    try {
        [System.Net.Dns]::GetHostEntry($HostName) | Out-Null
        return $true
    } catch { return $false }
}

function Test-Tcp {
    param([string]$HostName, [int]$Port=443, [int]$TimeoutSec=5)
    $client = New-Object System.Net.Sockets.TcpClient
    try {
        $iar = $client.BeginConnect($HostName, $Port, $null, $null)
        $ok  = $iar.AsyncWaitHandle.WaitOne([TimeSpan]::FromSeconds($TimeoutSec), $false)
        return ($ok -and $client.Connected)
    } catch { return $false }
    finally { $client.Close() }
}

function Test-HttpSso {
    param(
        [string]$Url,
        [hashtable]$Headers,
        [int]$TimeoutSec = 25
    )

    # We set MaximumRedirection=0 so we can capture 3xx Location cleanly.
    try {
        $sw = [System.Diagnostics.Stopwatch]::StartNew()
        $resp = Invoke-WebRequest -Uri $Url -Method Get -Headers $Headers -MaximumRedirection 0 `
                                  -TimeoutSec $TimeoutSec -UseBasicParsing -ErrorAction Stop
        $sw.Stop()

        return @{
            HttpCode    = [int]$resp.StatusCode
            RedirectLoc = $null
            LatencyMs   = [int]$sw.ElapsedMilliseconds
            Error       = $null
        }
    } catch {
        $sw.Stop()
        $ex = $_.Exception

        # When MaxRedirection=0, PowerShell often throws for 3xx.
        if ($ex.Response -and $ex.Response.StatusCode) {
            $code = [int]$ex.Response.StatusCode
            $loc  = $ex.Response.Headers["Location"]
            return @{
                HttpCode    = $code
                RedirectLoc = $loc
                LatencyMs   = [int]$sw.ElapsedMilliseconds
                Error       = $null
            }
        }

        return @{
            HttpCode    = 0
            RedirectLoc = $null
            LatencyMs   = [int]$sw.ElapsedMilliseconds
            Error       = $ex.Message
        }
    }
}

$results = foreach ($w in $Websites) {
    $uri  = [uri]$w.Url
    $host = $uri.Host

    $dnsOk = Test-Dns -HostName $host
    $tcpOk = if ($dnsOk) { Test-Tcp -HostName $host -Port 443 -TimeoutSec 5 } else { $false }

    $http = if ($tcpOk) { Test-HttpSso -Url $w.Url -Headers $Headers -TimeoutSec 25 } else {
        @{ HttpCode=0; RedirectLoc=$null; LatencyMs=0; Error="Skipped HTTP (DNS/TCP failed)" }
    }

    $httpPass = ($PassCodes -contains $http.HttpCode)
    $overall  = if ($dnsOk -and $tcpOk -and $httpPass) { "PASS" } elseif (-not $dnsOk -or -not $tcpOk) { "FAIL" } else { "WARN" }

    $redirectTo = ""
    if ($http.RedirectLoc) {
        try { $redirectTo = ([uri]$http.RedirectLoc).Host } catch { $redirectTo = $http.RedirectLoc }
    }

    $idpMatch = $false
    if ($http.RedirectLoc) {
        $idpMatch = $IdpKeywords | Where-Object { $http.RedirectLoc -match $_ } | ForEach-Object { $true } | Select-Object -First 1
        if (-not $idpMatch) { $idpMatch = $false }
    }

    [pscustomobject]@{
        Name        = $w.Name
        Url         = $w.Url
        DNS         = if ($dnsOk) { "Pass" } else { "Fail" }
        TCP443      = if ($tcpOk) { "Pass" } else { "Fail" }
        HttpCode    = $http.HttpCode
        HttpStatus  = if ($httpPass) { "Pass" } else { "Fail" }
        RedirectTo  = $redirectTo
        IdpLooksOk  = if ($http.RedirectLoc) { [bool]$idpMatch } else { $null }
        LatencyMs   = $http.LatencyMs
        Overall     = $overall
        Error       = $http.Error
    }
}

# Console output (clean for Jenkins logs)
$results | Sort-Object Overall, Name | Format-Table -AutoSize

# Exports
$outDir = "$PSScriptRoot\output"
if (!(Test-Path $outDir)) { New-Item -ItemType Directory -Path $outDir | Out-Null }

$csv  = Join-Path $outDir "sso_health.csv"
$json = Join-Path $outDir "sso_health.json"

$results | Export-Csv -NoTypeInformation -Path $csv
$results | ConvertTo-Json -Depth 6 | Set-Content -Encoding UTF8 -Path $json

Write-Host ""
Write-Host "Saved: $csv"
Write-Host "Saved: $json"

# Optional: exit non-zero for Jenkins if any FAIL
if ($results.Overall -contains "FAIL") { exit 1 } else { exit 0 }

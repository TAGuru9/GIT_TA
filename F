<# 
Mask selected columns in a delimited text/CSV file based on a config file.
Config file can be .csv, .xlsx, or .xls. Expected columns: ColumnName, Mask
#>

param(
    [Parameter(Mandatory=$true)]
    [string]$InputPath,

    [Parameter(Mandatory=$true)]
    [string]$ConfigPath,   # can be .csv / .xlsx / .xls

    [Parameter(Mandatory=$true)]
    [string]$OutputPath,

    [string]$Delimiter,      # optional override; else auto-detect
    [char]$MaskChar = 'X'
)

function Test-File {
    param([string]$Path)
    if (-not (Test-Path -LiteralPath $Path)) {
        throw "File not found: $Path"
    }
}

function Get-DelimiterAuto {
    param([string]$Path)
    $line = (Get-Content -LiteralPath $Path -TotalCount 50 | Where-Object { $_ -and $_.Trim().Length -gt 0 } | Select-Object -First 1)
    if (-not $line) { return ',' }
    $candidates = @(',', '|', "`t", ';')
    $best = $candidates | ForEach-Object {
        [pscustomobject]@{ Delim = $_; Count = ($line -split [regex]::Escape($_)).Count - 1 }
    } | Sort-Object Count -Descending | Select-Object -First 1
    if ($best.Count -gt 0) { return $best.Delim } else { return ',' }
}

function Should-Mask {
    param([string]$value)
    return ($value -match '^(?i:y|yes|true|1)$')
}

function Get-MaskedValue {
    param([AllowNull()][object]$Value, [char]$MaskChar)
    if ($null -eq $Value) { return $null }
    $s = [string]$Value
    if ($s.Length -eq 0) { return $s }
    return ($MaskChar.ToString() * $s.Length)
}

function Read-Config {
    param([string]$ConfigPath)

    $ext = [IO.Path]::GetExtension($ConfigPath).ToLowerInvariant()

    if ($ext -in @('.xlsx', '.xls')) {
        # Try ImportExcel first
        $importExcelAvailable = Get-Module -ListAvailable -Name ImportExcel | ForEach-Object { $_ } | Measure-Object | Select-Object -ExpandProperty Count
        if ($importExcelAvailable -gt 0) {
            try {
                $cfg = Import-Excel -Path $ConfigPath
                return $cfg
            } catch {
                Write-Warning "Import-Excel failed: $_. Falling back to Excel COM if available."
            }
        }

        # Fallback: Excel COM (requires Microsoft Excel)
        $excel = $null; $workbook = $null; $worksheet = $null
        try {
            $excel = New-Object -ComObject Excel.Application
            $excel.Visible = $false
            $workbook = $excel.Workbooks.Open($ConfigPath)
            # Use first worksheet
            $worksheet = $workbook.Worksheets.Item(1)
            $used = $worksheet.UsedRange
            $vals = $used.Value2

            if (-not $vals) { throw "Config Excel appears empty: $ConfigPath" }

            # Build objects from headers
            # $vals is 2D array 1-based [row, col]
            $rowCount = $vals.GetLength(0)
            $colCount = $vals.GetLength(1)

            # Read headers (row 1)
            $headers = for ($c=1; $c -le $colCount; $c++) { [string]$vals[1, $c] }

            # Create PSCustomObjects for each subsequent row
            $list = New-Object System.Collections.Generic.List[object]
            for ($r=2; $r -le $rowCount; $r++) {
                $h = @{}
                for ($c=1; $c -le $colCount; $c++) {
                    $h[$headers[$c-1]] = $vals[$r, $c]
                }
                $list.Add([pscustomobject]$h) | Out-Null
            }
            return $list
        } catch {
            throw "Failed to read Excel config ($ConfigPath). Ensure ImportExcel module is installed or Excel is available. Error: $_"
        } finally {
            if ($workbook) { $workbook.Close($false) | Out-Null }
            if ($excel) { $excel.Quit() | Out-Null }
            # Release COM objects cleanly
            foreach ($o in @($worksheet, $workbook, $excel)) {
                if ($o) { [void][Runtime.InteropServices.Marshal]::ReleaseComObject($o) }
            }
            [GC]::Collect(); [GC]::WaitForPendingFinalizers()
        }
    }
    elseif ($ext -eq '.csv') {
        return Import-Csv -LiteralPath $ConfigPath
    }
    else {
        throw "Unsupported config extension '$ext'. Use .csv, .xlsx, or .xls."
    }
}

# ---- Validate inputs
Test-File -Path $InputPath
Test-File -Path $ConfigPath

# ---- Determine delimiter for DATA file
if (-not $PSBoundParameters.ContainsKey('Delimiter') -or [string]::IsNullOrWhiteSpace($Delimiter)) {
    $Delimiter = Get-DelimiterAuto -Path $InputPath
}
Write-Host "Using delimiter for data file: [$Delimiter]" -ForegroundColor Cyan

# ---- Read config (CSV or Excel)
$configRows = Read-Config -ConfigPath $ConfigPath

# ---- Build mask set
$maskColumns =
    $configRows |
    Where-Object { $_.ColumnName -and (Should-Mask ([string]$_.Mask)) } |
    Select-Object -ExpandProperty ColumnName -Unique

if (-not $maskColumns -or $maskColumns.Count -eq 0) {
    Write-Warning "No columns marked to mask (Y) in config. The output will be a copy of the input."
}

# ---- Import data file
try {
    $rows = Import-Csv -LiteralPath $InputPath -Delimiter $Delimiter
} catch {
    throw "Failed to read input file as delimited text: $InputPath. $_"
}

# ---- Mask rows
$maskedRows = foreach ($row in $rows) {
    $h = @{}
    foreach ($prop in $row.PSObject.Properties.Name) {
        $val = $row.$prop
        if ($maskColumns -contains $prop) {
            $h[$prop] = Get-MaskedValue -Value $val -MaskChar $MaskChar
        } else {
            $h[$prop] = $val
        }
    }
    [pscustomobject]$h
}

# ---- Export masked data
try {
    $maskedRows | Export-Csv -LiteralPath $OutputPath -Delimiter $Delimiter -NoTypeInformation -Encoding UTF8
    Write-Host "Masked file written to: $OutputPath" -ForegroundColor Green
} catch {
    throw "Failed to write masked output to $OutputPath. $_"
}

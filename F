<# 
.SYNOPSIS
  Mask selected columns in a delimited text/CSV file based on a config CSV.

.PARAMETER InputPath
  Path to the source data file (.txt/.csv) with a header row.

.PARAMETER ConfigPath
  Path to the config CSV with columns: ColumnName, Mask

.PARAMETER OutputPath
  Path to write the masked file.

.PARAMETER Delimiter
  Optional. Specify a delimiter if you donâ€™t want auto-detect. 
  Examples: ',', '|', "`t", ';'

.PARAMETER MaskChar
  Optional. Character used for masking. Default: 'X'

.EXAMPLE
  .\Mask-File.ps1 -InputPath 'C:\data\input.txt' -ConfigPath 'C:\data\mask_config.csv' -OutputPath 'C:\data\masked_output.txt'

.EXAMPLE
  .\Mask-File.ps1 -InputPath 'C:\data\input.csv' -ConfigPath 'C:\data\mask_config.csv' -OutputPath 'C:\data\masked_output.csv' -Delimiter '|' -MaskChar '*'
#>

param(
    [Parameter(Mandatory=$true)]
    [string]$InputPath,

    [Parameter(Mandatory=$true)]
    [string]$ConfigPath,

    [Parameter(Mandatory=$true)]
    [string]$OutputPath,

    [string]$Delimiter,      # If omitted, script will auto-detect
    [char]$MaskChar = 'X'
)

function Test-File {
    param([string]$Path)
    if (-not (Test-Path -LiteralPath $Path)) {
        throw "File not found: $Path"
    }
}

function Get-DelimiterAuto {
    param([string]$Path)

    # Read first non-empty line
    $line = (Get-Content -LiteralPath $Path -TotalCount 50 | Where-Object { $_ -and $_.Trim().Length -gt 0 } | Select-Object -First 1)

    if (-not $line) { return ',' } # default fallback

    $candidates = @(',', '|', "`t", ';')
    $counts = foreach ($c in $candidates) {
        [pscustomobject]@{
            Delim = $c
            Count = ($line.ToCharArray() | ForEach-Object { $_ }) -join '' | Out-Null; ($line -split [regex]::Escape($c)).Count - 1
        }
    }
    # Pick the delimiter that appears the most in the header line
    $best = $counts | Sort-Object Count -Descending | Select-Object -First 1
    if ($best.Count -gt 0) { return $best.Delim } else { return ',' }
}

function Should-Mask {
    param([string]$value)
    return ($value -match '^(?i:y|yes|true|1)$')
}

function Get-MaskedValue {
    param(
        [AllowNull()][object]$Value,
        [char]$MaskChar
    )
    if ($null -eq $Value) { return $null }
    $s = [string]$Value
    if ($s.Length -eq 0) { return $s }
    return ($MaskChar.ToString() * $s.Length)
}

# ---- Validate inputs
Test-File -Path $InputPath
Test-File -Path $ConfigPath

# ---- Determine delimiter
if (-not $PSBoundParameters.ContainsKey('Delimiter') -or [string]::IsNullOrWhiteSpace($Delimiter)) {
    $Delimiter = Get-DelimiterAuto -Path $InputPath
}

Write-Host "Using delimiter: [$Delimiter]" -ForegroundColor Cyan

# ---- Read config and build mask set
try {
    $configRows = Import-Csv -LiteralPath $ConfigPath
} catch {
    throw "Failed to read config CSV: $ConfigPath. $_"
}

$maskColumns =
    $configRows |
    Where-Object { $_.ColumnName -and (Should-Mask $_.Mask) } |
    Select-Object -ExpandProperty ColumnName -Unique

if (-not $maskColumns -or $maskColumns.Count -eq 0) {
    Write-Warning "No columns marked to mask (Y) in $ConfigPath. The output will be a copy of the input."
}

# ---- Import data
try {
    $rows = Import-Csv -LiteralPath $InputPath -Delimiter $Delimiter
} catch {
    throw "Failed to read input file as delimited text: $InputPath. $_"
}

if (-not $rows -or $rows.Count -eq 0) {
    Write-Warning "No data rows found in input file: $InputPath"
}

# ---- Mask rows
$maskedRows = foreach ($row in $rows) {
    # Create a mutable copy
    $h = @{}
    foreach ($prop in $row.PSObject.Properties.Name) {
        $val = $row.$prop
        if ($maskColumns -contains $prop) {
            $h[$prop] = Get-MaskedValue -Value $val -MaskChar $MaskChar
        } else {
            $h[$prop] = $val
        }
    }
    [pscustomobject]$h
}

# ---- Export
try {
    $maskedRows | Export-Csv -LiteralPath $OutputPath -Delimiter $Delimiter -NoTypeInformation -Encoding UTF8
    Write-Host "Masked file written to: $OutputPath" -ForegroundColor Green
} catch {
    throw "Failed to write masked output to $OutputPath. $_"
}
